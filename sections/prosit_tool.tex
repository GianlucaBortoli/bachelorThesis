%!TEX root=../thesis.tex
\chapter{The PROSIT tool}\label{chp:tool}

% - LA BASE DA CUI PARTIRE E' IL PAPER \ref{prosit}
% + struttura dei moduli principali + linguaggio + librerie utilizzate + OOP patterns 
% + use cases diagram (vedi paper) 
% - focus nella creazione dei task RR (qbd_rr_colver.cpp) e di come abbiamo migliorato
%   la creazione della matrice (costruita in 3 fasi separate) in modo da sfruttare a pieno
%   le regolarità presenti al suo interno --> dati su quanto siano migliorate le performance 
%   dopo le modifiche (vedi mail con Bernardo per i numeri)
% - l'approssimazione conservativa della PMF (sia in alto che in basso)
% - distinzione solver da linea di comando e per xml
%     [*] solver_command_line e descrizione parametri in input
%     [*] xml_solver con esempi di chiamata + spiegazione struttura dell'xml da dare in input
% - descrizione web interface e motivi per cui è stata fatta (facilità d'uso per la creazione
%   dell'xml da zero)

\section{Internal structure}
PROSIT is written in C++ and has a modular structure, as an Object Oriented Programming (OOP) implicitly suggests to use.\\
Some external libraries have been used, in order to increase the performance on the matrix operarions and to simplify some other operations. The most important ones are \emph{Eigen}\footnote{\url{http://eigen.tuxfamily.org}}, \emph{TinyXML-2}\footnote{\url{https://github.com/leethomason/tinyxml2}} and \emph{Doxygen}\footnote{\url{http://www.stack.nl/~dimitri/doxygen/}}.\\   
Eigen is the most important library for the core of the tool: it is versatile, because it supports matrices and vectors of all sizes (bot fixed and dynamic) with a lot of matrix operarions already implemented, reliable and very fast, because performance can become a real problem when the matrices have hundreds and hundreds of rows and columns.\\
The second one is TinyXML-2, which has been used as a core part in the parser for the XML file. It provides APIs to accesso to an XML file (which is treated as a Document Object Model) as a C++ object that can be easily browsed and manipulated.\\
The latted is Doxygen, a documentation generator for multiple programming languages. It is widely used in projects\footnote{A list of some projects which already use this tool to generate their documentation is available at \url{http://www.stack.nl/~dimitri/doxygen/projects.html}} because it is highly configurable, it can extract code structure (like class diagrams and so on) even from undocumented files and especially because it is possible to select the output format for the documentation (such as HTML, {\LaTeX} and Unix man pages).\\
The can be devided into standalone modules:
\begin{itemize}
  \item the distribution handler class, for both PMFs and CDFs.
  \item the task descriptor class, in which it is describet the inner structure of a task
  \item the XML parser and the utilities for the XML manipulation.
  \item the probability solver class, which is essentialy a wrapper object for the solving algorithm and the parameters for the RR task.
  \item the QBDP interpretation for the input task; it is the one that actually implements the functions to build the transition matrix and the solution algorithm for the probability solver class.
  \item the QoS function class, which is used to compute the final value for the quality of service, given the input task parameters.
  \item the command line and the XML solver are those which contains the main function that are compiled in order to obtain the executable files.
\end{itemize}

\begin{figure}[H]
  \center{\includegraphics[width=0.9\linewidth]{classdiagram.png}}
  \caption{The PROSIT class diagram generated by Doxygen.}
  \label{automaton}
\end{figure}

\section{Use cases}
The most common use case for the PROSIT tools is the analysis problem: the designer is required to enter the parameters to define the task he/she wishes to analyse.\\
Since a it can only be resource reservation task\footnote{The fixed priority type of task is currently under development and it is not available yet.}, the values for the time requirements (the PMF for the computation time and the one for the interarrival time, if the task is aperiodic) and the scheduling parameters \( Q_{i}^s \) and \( T_{i}^s \) must be provided. Thanks to the temporal isolation property defined in Equation \ref{schedCond}, it allows the tool to treat every task on its own if several tasks are passed as inputs to the tool. The distribution functions can be specified inside the task or taken as input from a file.
\begin{figure}[H]
  \center{\includegraphics[width=0.7\linewidth]{usecase.png}}
  \caption{The analysis use case for the tool.}
  \label{usecase}
\end{figure}

As a result of a tool invocation, all the provided information are analysed and then the solver for the probabilisti deadlines is called. The \emph{apply\_algorithm()} method called by the probability solver object is a pure virtual function\footnote{Pure virtual functions in C++ are used to take advantage of polymorphism. This is essential for providing a unique interface for multiple objects, which implements different versions of the same method, based on the input selection.}; this allows PROSIT to call the right solution strategy selected by the user.\\
The results and their computation times are printed either on the screen or on a text file.

\section{RR solver}
This solver for resource reservation tasks are based on algorithms for a numerica solution of the relative quasi-birth death process and implements the following methods:
\begin{lstlisting}[frame=bt]
  void pre_process();
  bool compute_pi0();
  void post_process();
  void fill_in_probability_map();
\end{lstlisting}
The \emph{pre\_process()} function creates the matrices used by the QBD algorithms, which are implemented in every sublclass under the name of \emph{apply\_algorithm()}. The second method is responsible of computing the probabilities from the matrix computed earlier. At the end \emph{post\_process()} guarantees that the algorithm gives a reasonable output, while the last method fills the map which is used to display te computation results.\\
The functions described above are called by the solver in the order in which they have been presented.

\subsection{Focus on matrix creation}
The creation of the transition matrix which is later used to apply the algorithms can result in a critical performance bottleneck, since the size can be huge\footnote{Some tests we performed developing the tool calculated the algorithms on a matrix had a size od nearly one thousand.}. Given that the complexity of the algorithms mentioned in Section \ref{benefits} cannot be changed, this will certainly explain the motivation behind the effort to optimize as much as possible the matrix creation phase of the tool.\\
As explained in \ref{transitionmatrix}, the whole transition matrix has a recurrent block structure.\\ 
The first step is to limit the matrix size to the one of \( C \), \( A_{0} \), \( A_{1} \) and \( A_{2} \), since it can be theoretically have an infinite size, which makes it intractable computationally speaking. The values for \( max_{rows} \) and \( max_{cols} \) must be computed first, which are the maximum possible number of rows and columns respectively.\\ 
They can be evaluated as follows: 
\begin{equation*}
\begin{split}
  max_{rows} &= i.get_min() * Q + 1 \\
  max_{cols} &= c.get_max() + 1
\end{split}
\end{equation*}

where \( i.get\_min() \) returns the minimum value for the interarrival time, \( c.get\_max() \) returns the maximum value for the computation time and \( Q \) is the budget associated with the given task.\\
Then, after taking \( max_{v} = max\{max_{rows}\,,\,max_{cols}\} \) as a the size of one of the above mentioned matrices, it is possible to know that the size of the matrix is \( 2 \times max_{v} \).\\
The approach used to calculate the values inside the matrix is based on its internal structure, which is in proven\cite{pipelines} to be like:
\begin{figure}[H]
\begin{equation*} \label{transitionmatrix2}
  P_{i} = 
  \begin{bmatrix}
    a_{i,0} & a_{i,1} & a_{i,H_{i}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
    \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots\\
    a_{i,0} & a_{i,1} & a_{i,H_{i}} & 0 & \cdots & \cdots & \cdots & \cdots & \cdots & \cdots \\
    b_{i,0,0} & b_{i,0,1} & b_{i,0,H_{i}} & b_{i,0,H_{i}+1} & 0 & \cdots & \cdots & \cdots & \cdots & \cdots \\
    b_{i,0,0} & b_{i,0,1} & b_{i,0,H_{i}} & b_{i,0,H_{i}+1} & b_{i,0,H_{i}+2} & 0 & \cdots & \cdots & \cdots \\
    \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \ddots & \vdots & \vdots & \vdots \\
    b_{i,G_{i},0} & b_{i,G_{i},1} & \cdots & b_{i,G_{i},H_{i}} & b_{i,G_{i},H_{i}+1} & \cdots & \cdots & b_{i,G_{i},F_{i}} & 0 & \cdots \\
    0 & c_{i,0} & c_{i,1} & \cdots & c_{i,H_{i}} & c_{i,H_{i}+1} & \cdots & c_{i,F_{i}-1} & c_{i,F_{i}} & \ddots \\
    \vdots & \ddots & \ddots & \ddots & \ddots & \ddots & \ddots & \ddots & \ddots & \ddots
  \end{bmatrix}
\end{equation*}
\caption{The transition matrix for the generic \( i^{th} \) stage.}
\end{figure}

In the \( P_{i} \) matrix just described it is possible to spot an internal recurrent configuration, which is highlighted with the different names for the rows \emph{a}, \emph{b} and \emph{c}.\\
To take advantage of this proprerty, the \emph{pre\_process()} method builds the matrix in three steps: the first one is to calculate only the first \emph{a}-row block and then copy its value througout the rest of the first block. Secondly all the \emph{transient}\footnote{This part of the matrix exists only if the task is aperiodic. In the case of a periodic one, this part of the matrix does not exists and the transition matrix is composed only of the \emph{a} and \emph{c} blocks.} rows denoted with the letter \emph{b} are calculated, cell by cell. In the \emph{c} block, as happened for the first one, only the first row is calculated and then it is copied to the following one shifted right by one.