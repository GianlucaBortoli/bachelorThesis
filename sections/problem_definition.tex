%!TEX root=../thesis.tex
\chapter{Problem definition}\label{chp:model}

% - formal task definition
% - periodic, aperiodic and sporadic tasks
% - schedulers + (preemptive & non-preemptive)?
% - define RR and its properties
% - markov process background
% - quasi birth-deadth process
% - why we modeled task like this

\section{The task model}
We consider a set of real-time tasks \( \{\tau_{i}\} \) which share a processing unit (CPU), where every tast consists of a stream of jobs \( J_{i,\,k} \).\\
Each job \( j_{i,\,k} \) is defined as a touple \( \left(r_{i,\,k}, \;f_{i,\,k}, \;c_{i,\,k}\right) \) in which:

\begin{itemize}
  \item \( r_{i,\,k} \) is the \emph{release} time for the \( k_{th} \) instance of the \( i_{th} \) task. In other words this is the time in which the job arrives and becomes elegible for execution by the scheduler.
  \item \( f_{i,\,k} \) is the \emph{finishing} time, that is the moment in which the computation for the \( j_{i,\,k} \) ends.
  \item \( c_{i,\,k} \) is the \emph{computation} time, that is the amount of time for which the \( j_{i,\,k} \) was running.
\end{itemize} 

The computation time is assumed to be an independent and identically distributed (i.i.d.\footnote{Two random variables X and Y are said to be i.i.d. if the first has the same probability distribution of the second one and both are mutually indipendent, which means that the occurrence of X does not affect Y (and vice versa).}) stochastic process, since the soft real-time model we are going to explain and use is based on probabilistic deadlines rather than the classic hard deadline.\\
Hence for each \( k \), \( c_{i,\,k} \) is a random variable described by a certain Probability Mass Function (PMF).\\
Every job \( J_{i,\,k} \) has also a relative deadline \( D_{i} \), which is used to define the absolute deadline \( d_{i,\,k} = r_{i,\,k} + D_{i} \). \\
A deadline is respected if \( f_{i,\,k} \leq d_{i,\,k} \) and it is missed if \( f_{i,\,k} > d_{i,\,k} \). In order to be more precise, a probabilistic deadline is respected if \( \Pr\{f_{i,\,k} > r_{i,\,k} + D_{i} \} \leq p_{i} \).\\

\section{Different type of tasks}
There are three types of tasks: \emph{periodic}, \emph{aperiodic} and \emph{sporadic}.\\
A periodic task has a regular structure and is triggered every period \( T_{i} \). Its lifetime is similar to a cycle in which it activates at time \( r_{i,\,k} \), executes its computation for a period \( c_{i,\,k} \) and then waits the next period to start running again.\\
The second class is composed of these tasks which are not characterize by periodic arrivals. Moreover a minimim interarrival time between different tasks does not exists and, generally speaking, they have not any recurrent structure. They are used to model tasks which occur rarely and have an irregular inner structure.\\
The last type of tasks are very similar to the periodic ones, because both have a minimin interarrival time between each activation, even though it is not always the same. A sporadic task is triggered by an external event which needs the task to be activated, not a timer as happens in for a periodic one.\\
The work which will be described in following chapters takes into consideration only the first two types of tasks.

\section{The task scheduler}
The tasks do not run on the bare computer hardware: the operating system (OS) creates the illusion for each task to have a virtual CPU where they can execute on their own, without the need to share it with anyone else. This gives them the illusion that they are running concurrently and in parallel on the same machine \footnote{This is true if we think of a CPU with one single core. Modern CPUs are multicore, which gives the possibility to actually run multiple tasks at the same time, with an upper bound for the number of process to be executed in parallel given by the number of cores}.\\
Since it is possible to run only one task at a time they need to alternate each other, in order to give everyone the possibility to get their work done. Here is when the \emph{task scheduler} starts its job. The scheduler is responsible for generating a \emph{schedule}, starting from a set of tasks \( \{\tau_{i}\} \).\\
There are several scheduling algorithm which are used to select at every instant \emph{t} which is the task to be executed. More in general a scheduling algorithm \emph{A} generates a schedule \( \sigma_{A}\left(t\right) \) starting from a set of tasks \( \{\tau_{i}\} \).\\
At the end a schedulability test is performed, in which it is checked if the schedule generated by the algorithm \emph{A} guarantees that every deadline (probabilistic or not) is met.\\
There are lots of scheduling algorithm which can be used, such as rate monotonic (RM), earliest deadline first (EDF) and many others, but we concentrated on the \emph{SCHED\_DEADLINE} algorithm, which is the scheduler currently used in the Linux kernel \footnote{It became the default scheduler from the 3.14 version of the kernel and it is still the one present in the latest kernel available on \url{www.kernel.org}. The old one was a modified version of the EDF algorithm}.\\


\section{The stochastic model}